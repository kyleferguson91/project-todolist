(self["webpackChunkproject_todolist"] = self["webpackChunkproject_todolist"] || []).push([["vendors-node_modules_commander_index_js"],{

/***/ "./node_modules/commander/index.js":
/*!*****************************************!*\
  !*** ./node_modules/commander/index.js ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

var EventEmitter = (__webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter);
var spawn = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'child_process'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
var path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'path'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
var dirname = path.dirname;
var basename = path.basename;
var fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'fs'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

/**
 * Inherit `Command` from `EventEmitter.prototype`.
 */

Object(function webpackMissingModule() { var e = new Error("Cannot find module 'util'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())(Command, EventEmitter);

/**
 * Expose the root command.
 */

exports = module.exports = new Command();

/**
 * Expose `Command`.
 */

exports.Command = Command;

/**
 * Expose `Option`.
 */

exports.Option = Option;

/**
 * Initialize a new `Option` with the given `flags` and `description`.
 *
 * @param {String} flags
 * @param {String} description
 * @api public
 */

function Option(flags, description) {
  this.flags = flags;
  this.required = flags.indexOf('<') >= 0;
  this.optional = flags.indexOf('[') >= 0;
  this.bool = flags.indexOf('-no-') === -1;
  flags = flags.split(/[ ,|]+/);
  if (flags.length > 1 && !/^[[<]/.test(flags[1])) this.short = flags.shift();
  this.long = flags.shift();
  this.description = description || '';
}

/**
 * Return option name.
 *
 * @return {String}
 * @api private
 */

Option.prototype.name = function() {
  return this.long
    .replace('--', '')
    .replace('no-', '');
};

/**
 * Return option name, in a camelcase format that can be used
 * as a object attribute key.
 *
 * @return {String}
 * @api private
 */

Option.prototype.attributeName = function() {
  return camelcase(this.name());
};

/**
 * Check if `arg` matches the short or long flag.
 *
 * @param {String} arg
 * @return {Boolean}
 * @api private
 */

Option.prototype.is = function(arg) {
  return this.short === arg || this.long === arg;
};

/**
 * Initialize a new `Command`.
 *
 * @param {String} name
 * @api public
 */

function Command(name) {
  this.commands = [];
  this.options = [];
  this._execs = {};
  this._allowUnknownOption = false;
  this._args = [];
  this._name = name || '';
}

/**
 * Add command `name`.
 *
 * The `.action()` callback is invoked when the
 * command `name` is specified via __ARGV__,
 * and the remaining arguments are applied to the
 * function for access.
 *
 * When the `name` is "*" an un-matched command
 * will be passed as the first arg, followed by
 * the rest of __ARGV__ remaining.
 *
 * Examples:
 *
 *      program
 *        .version('0.0.1')
 *        .option('-C, --chdir <path>', 'change the working directory')
 *        .option('-c, --config <path>', 'set config path. defaults to ./deploy.conf')
 *        .option('-T, --no-tests', 'ignore test hook')
 *
 *      program
 *        .command('setup')
 *        .description('run remote setup commands')
 *        .action(function() {
 *          console.log('setup');
 *        });
 *
 *      program
 *        .command('exec <cmd>')
 *        .description('run the given remote command')
 *        .action(function(cmd) {
 *          console.log('exec "%s"', cmd);
 *        });
 *
 *      program
 *        .command('teardown <dir> [otherDirs...]')
 *        .description('run teardown commands')
 *        .action(function(dir, otherDirs) {
 *          console.log('dir "%s"', dir);
 *          if (otherDirs) {
 *            otherDirs.forEach(function (oDir) {
 *              console.log('dir "%s"', oDir);
 *            });
 *          }
 *        });
 *
 *      program
 *        .command('*')
 *        .description('deploy the given env')
 *        .action(function(env) {
 *          console.log('deploying "%s"', env);
 *        });
 *
 *      program.parse(process.argv);
  *
 * @param {String} name
 * @param {String} [desc] for git-style sub-commands
 * @return {Command} the new command
 * @api public
 */

Command.prototype.command = function(name, desc, opts) {
  if (typeof desc === 'object' && desc !== null) {
    opts = desc;
    desc = null;
  }
  opts = opts || {};
  var args = name.split(/ +/);
  var cmd = new Command(args.shift());

  if (desc) {
    cmd.description(desc);
    this.executables = true;
    this._execs[cmd._name] = true;
    if (opts.isDefault) this.defaultExecutable = cmd._name;
  }
  cmd._noHelp = !!opts.noHelp;
  this.commands.push(cmd);
  cmd.parseExpectedArgs(args);
  cmd.parent = this;

  if (desc) return this;
  return cmd;
};

/**
 * Define argument syntax for the top-level command.
 *
 * @api public
 */

Command.prototype.arguments = function(desc) {
  return this.parseExpectedArgs(desc.split(/ +/));
};

/**
 * Add an implicit `help [cmd]` subcommand
 * which invokes `--help` for the given command.
 *
 * @api private
 */

Command.prototype.addImplicitHelpCommand = function() {
  this.command('help [cmd]', 'display help for [cmd]');
};

/**
 * Parse expected `args`.
 *
 * For example `["[type]"]` becomes `[{ required: false, name: 'type' }]`.
 *
 * @param {Array} args
 * @return {Command} for chaining
 * @api public
 */

Command.prototype.parseExpectedArgs = function(args) {
  if (!args.length) return;
  var self = this;
  args.forEach(function(arg) {
    var argDetails = {
      required: false,
      name: '',
      variadic: false
    };

    switch (arg[0]) {
      case '<':
        argDetails.required = true;
        argDetails.name = arg.slice(1, -1);
        break;
      case '[':
        argDetails.name = arg.slice(1, -1);
        break;
    }

    if (argDetails.name.length > 3 && argDetails.name.slice(-3) === '...') {
      argDetails.variadic = true;
      argDetails.name = argDetails.name.slice(0, -3);
    }
    if (argDetails.name) {
      self._args.push(argDetails);
    }
  });
  return this;
};

/**
 * Register callback `fn` for the command.
 *
 * Examples:
 *
 *      program
 *        .command('help')
 *        .description('display verbose help')
 *        .action(function() {
 *           // output help here
 *        });
 *
 * @param {Function} fn
 * @return {Command} for chaining
 * @api public
 */

Command.prototype.action = function(fn) {
  var self = this;
  var listener = function(args, unknown) {
    // Parse any so-far unknown options
    args = args || [];
    unknown = unknown || [];

    var parsed = self.parseOptions(unknown);

    // Output help if necessary
    outputHelpIfNecessary(self, parsed.unknown);

    // If there are still any unknown options, then we simply
    // die, unless someone asked for help, in which case we give it
    // to them, and then we die.
    if (parsed.unknown.length > 0) {
      self.unknownOption(parsed.unknown[0]);
    }

    // Leftover arguments need to be pushed back. Fixes issue #56
    if (parsed.args.length) args = parsed.args.concat(args);

    self._args.forEach(function(arg, i) {
      if (arg.required && args[i] == null) {
        self.missingArgument(arg.name);
      } else if (arg.variadic) {
        if (i !== self._args.length - 1) {
          self.variadicArgNotLast(arg.name);
        }

        args[i] = args.splice(i);
      }
    });

    // Always append ourselves to the end of the arguments,
    // to make sure we match the number of arguments the user
    // expects
    if (self._args.length) {
      args[self._args.length] = self;
    } else {
      args.push(self);
    }

    fn.apply(self, args);
  };
  var parent = this.parent || this;
  var name = parent === this ? '*' : this._name;
  parent.on('command:' + name, listener);
  if (this._alias) parent.on('command:' + this._alias, listener);
  return this;
};

/**
 * Define option with `flags`, `description` and optional
 * coercion `fn`.
 *
 * The `flags` string should contain both the short and long flags,
 * separated by comma, a pipe or space. The following are all valid
 * all will output this way when `--help` is used.
 *
 *    "-p, --pepper"
 *    "-p|--pepper"
 *    "-p --pepper"
 *
 * Examples:
 *
 *     // simple boolean defaulting to false
 *     program.option('-p, --pepper', 'add pepper');
 *
 *     --pepper
 *     program.pepper
 *     // => Boolean
 *
 *     // simple boolean defaulting to true
 *     program.option('-C, --no-cheese', 'remove cheese');
 *
 *     program.cheese
 *     // => true
 *
 *     --no-cheese
 *     program.cheese
 *     // => false
 *
 *     // required argument
 *     program.option('-C, --chdir <path>', 'change the working directory');
 *
 *     --chdir /tmp
 *     program.chdir
 *     // => "/tmp"
 *
 *     // optional argument
 *     program.option('-c, --cheese [type]', 'add cheese [marble]');
 *
 * @param {String} flags
 * @param {String} description
 * @param {Function|*} [fn] or default
 * @param {*} [defaultValue]
 * @return {Command} for chaining
 * @api public
 */

Command.prototype.option = function(flags, description, fn, defaultValue) {
  var self = this,
    option = new Option(flags, description),
    oname = option.name(),
    name = option.attributeName();

  // default as 3rd arg
  if (typeof fn !== 'function') {
    if (fn instanceof RegExp) {
      var regex = fn;
      fn = function(val, def) {
        var m = regex.exec(val);
        return m ? m[0] : def;
      };
    } else {
      defaultValue = fn;
      fn = null;
    }
  }

  // preassign default value only for --no-*, [optional], or <required>
  if (!option.bool || option.optional || option.required) {
    // when --no-* we make sure default is true
    if (!option.bool) defaultValue = true;
    // preassign only if we have a default
    if (defaultValue !== undefined) {
      self[name] = defaultValue;
      option.defaultValue = defaultValue;
    }
  }

  // register the option
  this.options.push(option);

  // when it's passed assign the value
  // and conditionally invoke the callback
  this.on('option:' + oname, function(val) {
    // coercion
    if (val !== null && fn) {
      val = fn(val, self[name] === undefined ? defaultValue : self[name]);
    }

    // unassigned or bool
    if (typeof self[name] === 'boolean' || typeof self[name] === 'undefined') {
      // if no value, bool true, and we have a default, then use it!
      if (val == null) {
        self[name] = option.bool
          ? defaultValue || true
          : false;
      } else {
        self[name] = val;
      }
    } else if (val !== null) {
      // reassign
      self[name] = val;
    }
  });

  return this;
};

/**
 * Allow unknown options on the command line.
 *
 * @param {Boolean} arg if `true` or omitted, no error will be thrown
 * for unknown options.
 * @api public
 */
Command.prototype.allowUnknownOption = function(arg) {
  this._allowUnknownOption = arguments.length === 0 || arg;
  return this;
};

/**
 * Parse `argv`, settings options and invoking commands when defined.
 *
 * @param {Array} argv
 * @return {Command} for chaining
 * @api public
 */

Command.prototype.parse = function(argv) {
  // implicit help
  if (this.executables) this.addImplicitHelpCommand();

  // store raw args
  this.rawArgs = argv;

  // guess name
  this._name = this._name || basename(argv[1], '.js');

  // github-style sub-commands with no sub-command
  if (this.executables && argv.length < 3 && !this.defaultExecutable) {
    // this user needs help
    argv.push('--help');
  }

  // process argv
  var parsed = this.parseOptions(this.normalize(argv.slice(2)));
  var args = this.args = parsed.args;

  var result = this.parseArgs(this.args, parsed.unknown);

  // executable sub-commands
  var name = result.args[0];

  var aliasCommand = null;
  // check alias of sub commands
  if (name) {
    aliasCommand = this.commands.filter(function(command) {
      return command.alias() === name;
    })[0];
  }

  if (this._execs[name] === true) {
    return this.executeSubCommand(argv, args, parsed.unknown);
  } else if (aliasCommand) {
    // is alias of a subCommand
    args[0] = aliasCommand._name;
    return this.executeSubCommand(argv, args, parsed.unknown);
  } else if (this.defaultExecutable) {
    // use the default subcommand
    args.unshift(this.defaultExecutable);
    return this.executeSubCommand(argv, args, parsed.unknown);
  }

  return result;
};

/**
 * Execute a sub-command executable.
 *
 * @param {Array} argv
 * @param {Array} args
 * @param {Array} unknown
 * @api private
 */

Command.prototype.executeSubCommand = function(argv, args, unknown) {
  args = args.concat(unknown);

  if (!args.length) this.help();
  if (args[0] === 'help' && args.length === 1) this.help();

  // <cmd> --help
  if (args[0] === 'help') {
    args[0] = args[1];
    args[1] = '--help';
  }

  // executable
  var f = argv[1];
  // name of the subcommand, link `pm-install`
  var bin = basename(f, path.extname(f)) + '-' + args[0];

  // In case of globally installed, get the base dir where executable
  //  subcommand file should be located at
  var baseDir;

  var resolvedLink = fs.realpathSync(f);

  baseDir = dirname(resolvedLink);

  // prefer local `./<bin>` to bin in the $PATH
  var localBin = path.join(baseDir, bin);

  // whether bin file is a js script with explicit `.js` or `.ts` extension
  var isExplicitJS = false;
  if (exists(localBin + '.js')) {
    bin = localBin + '.js';
    isExplicitJS = true;
  } else if (exists(localBin + '.ts')) {
    bin = localBin + '.ts';
    isExplicitJS = true;
  } else if (exists(localBin)) {
    bin = localBin;
  }

  args = args.slice(1);

  var proc;
  if (process.platform !== 'win32') {
    if (isExplicitJS) {
      args.unshift(bin);
      // add executable arguments to spawn
      args = (process.execArgv || []).concat(args);

      proc = spawn(process.argv[0], args, { stdio: 'inherit', customFds: [0, 1, 2] });
    } else {
      proc = spawn(bin, args, { stdio: 'inherit', customFds: [0, 1, 2] });
    }
  } else {
    args.unshift(bin);
    proc = spawn(process.execPath, args, { stdio: 'inherit' });
  }

  var signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];
  signals.forEach(function(signal) {
    process.on(signal, function() {
      if (proc.killed === false && proc.exitCode === null) {
        proc.kill(signal);
      }
    });
  });
  proc.on('close', process.exit.bind(process));
  proc.on('error', function(err) {
    if (err.code === 'ENOENT') {
      console.error('error: %s(1) does not exist, try --help', bin);
    } else if (err.code === 'EACCES') {
      console.error('error: %s(1) not executable. try chmod or run with root', bin);
    }
    process.exit(1);
  });

  // Store the reference to the child process
  this.runningCommand = proc;
};

/**
 * Normalize `args`, splitting joined short flags. For example
 * the arg "-abc" is equivalent to "-a -b -c".
 * This also normalizes equal sign and splits "--abc=def" into "--abc def".
 *
 * @param {Array} args
 * @return {Array}
 * @api private
 */

Command.prototype.normalize = function(args) {
  var ret = [],
    arg,
    lastOpt,
    index;

  for (var i = 0, len = args.length; i < len; ++i) {
    arg = args[i];
    if (i > 0) {
      lastOpt = this.optionFor(args[i - 1]);
    }

    if (arg === '--') {
      // Honor option terminator
      ret = ret.concat(args.slice(i));
      break;
    } else if (lastOpt && lastOpt.required) {
      ret.push(arg);
    } else if (arg.length > 1 && arg[0] === '-' && arg[1] !== '-') {
      arg.slice(1).split('').forEach(function(c) {
        ret.push('-' + c);
      });
    } else if (/^--/.test(arg) && ~(index = arg.indexOf('='))) {
      ret.push(arg.slice(0, index), arg.slice(index + 1));
    } else {
      ret.push(arg);
    }
  }

  return ret;
};

/**
 * Parse command `args`.
 *
 * When listener(s) are available those
 * callbacks are invoked, otherwise the "*"
 * event is emitted and those actions are invoked.
 *
 * @param {Array} args
 * @return {Command} for chaining
 * @api private
 */

Command.prototype.parseArgs = function(args, unknown) {
  var name;

  if (args.length) {
    name = args[0];
    if (this.listeners('command:' + name).length) {
      this.emit('command:' + args.shift(), args, unknown);
    } else {
      this.emit('command:*', args);
    }
  } else {
    outputHelpIfNecessary(this, unknown);

    // If there were no args and we have unknown options,
    // then they are extraneous and we need to error.
    if (unknown.length > 0) {
      this.unknownOption(unknown[0]);
    }
    if (this.commands.length === 0 &&
        this._args.filter(function(a) { return a.required; }).length === 0) {
      this.emit('command:*');
    }
  }

  return this;
};

/**
 * Return an option matching `arg` if any.
 *
 * @param {String} arg
 * @return {Option}
 * @api private
 */

Command.prototype.optionFor = function(arg) {
  for (var i = 0, len = this.options.length; i < len; ++i) {
    if (this.options[i].is(arg)) {
      return this.options[i];
    }
  }
};

/**
 * Parse options from `argv` returning `argv`
 * void of these options.
 *
 * @param {Array} argv
 * @return {Array}
 * @api public
 */

Command.prototype.parseOptions = function(argv) {
  var args = [],
    len = argv.length,
    literal,
    option,
    arg;

  var unknownOptions = [];

  // parse options
  for (var i = 0; i < len; ++i) {
    arg = argv[i];

    // literal args after --
    if (literal) {
      args.push(arg);
      continue;
    }

    if (arg === '--') {
      literal = true;
      continue;
    }

    // find matching Option
    option = this.optionFor(arg);

    // option is defined
    if (option) {
      // requires arg
      if (option.required) {
        arg = argv[++i];
        if (arg == null) return this.optionMissingArgument(option);
        this.emit('option:' + option.name(), arg);
      // optional arg
      } else if (option.optional) {
        arg = argv[i + 1];
        if (arg == null || (arg[0] === '-' && arg !== '-')) {
          arg = null;
        } else {
          ++i;
        }
        this.emit('option:' + option.name(), arg);
      // bool
      } else {
        this.emit('option:' + option.name());
      }
      continue;
    }

    // looks like an option
    if (arg.length > 1 && arg[0] === '-') {
      unknownOptions.push(arg);

      // If the next argument looks like it might be
      // an argument for this option, we pass it on.
      // If it isn't, then it'll simply be ignored
      if ((i + 1) < argv.length && argv[i + 1][0] !== '-') {
        unknownOptions.push(argv[++i]);
      }
      continue;
    }

    // arg
    args.push(arg);
  }

  return { args: args, unknown: unknownOptions };
};

/**
 * Return an object containing options as key-value pairs
 *
 * @return {Object}
 * @api public
 */
Command.prototype.opts = function() {
  var result = {},
    len = this.options.length;

  for (var i = 0; i < len; i++) {
    var key = this.options[i].attributeName();
    result[key] = key === this._versionOptionName ? this._version : this[key];
  }
  return result;
};

/**
 * Argument `name` is missing.
 *
 * @param {String} name
 * @api private
 */

Command.prototype.missingArgument = function(name) {
  console.error("error: missing required argument `%s'", name);
  process.exit(1);
};

/**
 * `Option` is missing an argument, but received `flag` or nothing.
 *
 * @param {String} option
 * @param {String} flag
 * @api private
 */

Command.prototype.optionMissingArgument = function(option, flag) {
  if (flag) {
    console.error("error: option `%s' argument missing, got `%s'", option.flags, flag);
  } else {
    console.error("error: option `%s' argument missing", option.flags);
  }
  process.exit(1);
};

/**
 * Unknown option `flag`.
 *
 * @param {String} flag
 * @api private
 */

Command.prototype.unknownOption = function(flag) {
  if (this._allowUnknownOption) return;
  console.error("error: unknown option `%s'", flag);
  process.exit(1);
};

/**
 * Variadic argument with `name` is not the last argument as required.
 *
 * @param {String} name
 * @api private
 */

Command.prototype.variadicArgNotLast = function(name) {
  console.error("error: variadic arguments must be last `%s'", name);
  process.exit(1);
};

/**
 * Set the program version to `str`.
 *
 * This method auto-registers the "-V, --version" flag
 * which will print the version number when passed.
 *
 * @param {String} str
 * @param {String} [flags]
 * @return {Command} for chaining
 * @api public
 */

Command.prototype.version = function(str, flags) {
  if (arguments.length === 0) return this._version;
  this._version = str;
  flags = flags || '-V, --version';
  var versionOption = new Option(flags, 'output the version number');
  this._versionOptionName = versionOption.long.substr(2) || 'version';
  this.options.push(versionOption);
  this.on('option:' + this._versionOptionName, function() {
    process.stdout.write(str + '\n');
    process.exit(0);
  });
  return this;
};

/**
 * Set the description to `str`.
 *
 * @param {String} str
 * @param {Object} argsDescription
 * @return {String|Command}
 * @api public
 */

Command.prototype.description = function(str, argsDescription) {
  if (arguments.length === 0) return this._description;
  this._description = str;
  this._argsDescription = argsDescription;
  return this;
};

/**
 * Set an alias for the command
 *
 * @param {String} alias
 * @return {String|Command}
 * @api public
 */

Command.prototype.alias = function(alias) {
  var command = this;
  if (this.commands.length !== 0) {
    command = this.commands[this.commands.length - 1];
  }

  if (arguments.length === 0) return command._alias;

  if (alias === command._name) throw new Error('Command alias can\'t be the same as its name');

  command._alias = alias;
  return this;
};

/**
 * Set / get the command usage `str`.
 *
 * @param {String} str
 * @return {String|Command}
 * @api public
 */

Command.prototype.usage = function(str) {
  var args = this._args.map(function(arg) {
    return humanReadableArgName(arg);
  });

  var usage = '[options]' +
    (this.commands.length ? ' [command]' : '') +
    (this._args.length ? ' ' + args.join(' ') : '');

  if (arguments.length === 0) return this._usage || usage;
  this._usage = str;

  return this;
};

/**
 * Get or set the name of the command
 *
 * @param {String} str
 * @return {String|Command}
 * @api public
 */

Command.prototype.name = function(str) {
  if (arguments.length === 0) return this._name;
  this._name = str;
  return this;
};

/**
 * Return prepared commands.
 *
 * @return {Array}
 * @api private
 */

Command.prototype.prepareCommands = function() {
  return this.commands.filter(function(cmd) {
    return !cmd._noHelp;
  }).map(function(cmd) {
    var args = cmd._args.map(function(arg) {
      return humanReadableArgName(arg);
    }).join(' ');

    return [
      cmd._name +
        (cmd._alias ? '|' + cmd._alias : '') +
        (cmd.options.length ? ' [options]' : '') +
        (args ? ' ' + args : ''),
      cmd._description
    ];
  });
};

/**
 * Return the largest command length.
 *
 * @return {Number}
 * @api private
 */

Command.prototype.largestCommandLength = function() {
  var commands = this.prepareCommands();
  return commands.reduce(function(max, command) {
    return Math.max(max, command[0].length);
  }, 0);
};

/**
 * Return the largest option length.
 *
 * @return {Number}
 * @api private
 */

Command.prototype.largestOptionLength = function() {
  var options = [].slice.call(this.options);
  options.push({
    flags: '-h, --help'
  });
  return options.reduce(function(max, option) {
    return Math.max(max, option.flags.length);
  }, 0);
};

/**
 * Return the largest arg length.
 *
 * @return {Number}
 * @api private
 */

Command.prototype.largestArgLength = function() {
  return this._args.reduce(function(max, arg) {
    return Math.max(max, arg.name.length);
  }, 0);
};

/**
 * Return the pad width.
 *
 * @return {Number}
 * @api private
 */

Command.prototype.padWidth = function() {
  var width = this.largestOptionLength();
  if (this._argsDescription && this._args.length) {
    if (this.largestArgLength() > width) {
      width = this.largestArgLength();
    }
  }

  if (this.commands && this.commands.length) {
    if (this.largestCommandLength() > width) {
      width = this.largestCommandLength();
    }
  }

  return width;
};

/**
 * Return help for options.
 *
 * @return {String}
 * @api private
 */

Command.prototype.optionHelp = function() {
  var width = this.padWidth();

  // Append the help information
  return this.options.map(function(option) {
    return pad(option.flags, width) + '  ' + option.description +
      ((option.bool && option.defaultValue !== undefined) ? ' (default: ' + JSON.stringify(option.defaultValue) + ')' : '');
  }).concat([pad('-h, --help', width) + '  ' + 'output usage information'])
    .join('\n');
};

/**
 * Return command help documentation.
 *
 * @return {String}
 * @api private
 */

Command.prototype.commandHelp = function() {
  if (!this.commands.length) return '';

  var commands = this.prepareCommands();
  var width = this.padWidth();

  return [
    'Commands:',
    commands.map(function(cmd) {
      var desc = cmd[1] ? '  ' + cmd[1] : '';
      return (desc ? pad(cmd[0], width) : cmd[0]) + desc;
    }).join('\n').replace(/^/gm, '  '),
    ''
  ].join('\n');
};

/**
 * Return program help documentation.
 *
 * @return {String}
 * @api private
 */

Command.prototype.helpInformation = function() {
  var desc = [];
  if (this._description) {
    desc = [
      this._description,
      ''
    ];

    var argsDescription = this._argsDescription;
    if (argsDescription && this._args.length) {
      var width = this.padWidth();
      desc.push('Arguments:');
      desc.push('');
      this._args.forEach(function(arg) {
        desc.push('  ' + pad(arg.name, width) + '  ' + argsDescription[arg.name]);
      });
      desc.push('');
    }
  }

  var cmdName = this._name;
  if (this._alias) {
    cmdName = cmdName + '|' + this._alias;
  }
  var usage = [
    'Usage: ' + cmdName + ' ' + this.usage(),
    ''
  ];

  var cmds = [];
  var commandHelp = this.commandHelp();
  if (commandHelp) cmds = [commandHelp];

  var options = [
    'Options:',
    '' + this.optionHelp().replace(/^/gm, '  '),
    ''
  ];

  return usage
    .concat(desc)
    .concat(options)
    .concat(cmds)
    .join('\n');
};

/**
 * Output help information for this command
 *
 * @api public
 */

Command.prototype.outputHelp = function(cb) {
  if (!cb) {
    cb = function(passthru) {
      return passthru;
    };
  }
  process.stdout.write(cb(this.helpInformation()));
  this.emit('--help');
};

/**
 * Output help information and exit.
 *
 * @api public
 */

Command.prototype.help = function(cb) {
  this.outputHelp(cb);
  process.exit();
};

/**
 * Camel-case the given `flag`
 *
 * @param {String} flag
 * @return {String}
 * @api private
 */

function camelcase(flag) {
  return flag.split('-').reduce(function(str, word) {
    return str + word[0].toUpperCase() + word.slice(1);
  });
}

/**
 * Pad `str` to `width`.
 *
 * @param {String} str
 * @param {Number} width
 * @return {String}
 * @api private
 */

function pad(str, width) {
  var len = Math.max(0, width - str.length);
  return str + Array(len + 1).join(' ');
}

/**
 * Output help information if necessary
 *
 * @param {Command} command to output help for
 * @param {Array} array of options to search for -h or --help
 * @api private
 */

function outputHelpIfNecessary(cmd, options) {
  options = options || [];
  for (var i = 0; i < options.length; i++) {
    if (options[i] === '--help' || options[i] === '-h') {
      cmd.outputHelp();
      process.exit(0);
    }
  }
}

/**
 * Takes an argument an returns its human readable equivalent for help usage.
 *
 * @param {Object} arg
 * @return {String}
 * @api private
 */

function humanReadableArgName(arg) {
  var nameOutput = arg.name + (arg.variadic === true ? '...' : '');

  return arg.required
    ? '<' + nameOutput + '>'
    : '[' + nameOutput + ']';
}

// for versions before node v0.8 when there weren't `fs.existsSync`
function exists(file) {
  try {
    if (fs.statSync(file).isFile()) {
      return true;
    }
  } catch (e) {
    return false;
  }
}


/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfY29tbWFuZGVyX2luZGV4X2pzLm1haW4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLG1GQUE4QjtBQUNqRCxZQUFZLDRJQUE4QjtBQUMxQyxXQUFXLG1CQUFPLENBQUMsbUlBQU07QUFDekI7QUFDQTtBQUNBLFNBQVMsbUJBQU8sQ0FBQyxpSUFBSTs7QUFFckI7QUFDQTtBQUNBOztBQUVBLG1JQUF3Qjs7QUFFeEI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlOztBQUVmO0FBQ0E7QUFDQTs7QUFFQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLCtCQUErQjtBQUN2RTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFNBQVM7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXLFVBQVU7QUFDckIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkIsV0FBVyxHQUFHO0FBQ2QsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZLFNBQVM7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0Es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Q0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFH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QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Byb2plY3QtdG9kb2xpc3QvLi9ub2RlX21vZHVsZXMvY29tbWFuZGVyL2luZGV4LmpzIiwid2VicGFjazovL3Byb2plY3QtdG9kb2xpc3QvLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBzcGF3biA9IHJlcXVpcmUoJ2NoaWxkX3Byb2Nlc3MnKS5zcGF3bjtcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xudmFyIGRpcm5hbWUgPSBwYXRoLmRpcm5hbWU7XG52YXIgYmFzZW5hbWUgPSBwYXRoLmJhc2VuYW1lO1xudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcblxuLyoqXG4gKiBJbmhlcml0IGBDb21tYW5kYCBmcm9tIGBFdmVudEVtaXR0ZXIucHJvdG90eXBlYC5cbiAqL1xuXG5yZXF1aXJlKCd1dGlsJykuaW5oZXJpdHMoQ29tbWFuZCwgRXZlbnRFbWl0dGVyKTtcblxuLyoqXG4gKiBFeHBvc2UgdGhlIHJvb3QgY29tbWFuZC5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBuZXcgQ29tbWFuZCgpO1xuXG4vKipcbiAqIEV4cG9zZSBgQ29tbWFuZGAuXG4gKi9cblxuZXhwb3J0cy5Db21tYW5kID0gQ29tbWFuZDtcblxuLyoqXG4gKiBFeHBvc2UgYE9wdGlvbmAuXG4gKi9cblxuZXhwb3J0cy5PcHRpb24gPSBPcHRpb247XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgT3B0aW9uYCB3aXRoIHRoZSBnaXZlbiBgZmxhZ3NgIGFuZCBgZGVzY3JpcHRpb25gLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmbGFnc1xuICogQHBhcmFtIHtTdHJpbmd9IGRlc2NyaXB0aW9uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIE9wdGlvbihmbGFncywgZGVzY3JpcHRpb24pIHtcbiAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICB0aGlzLnJlcXVpcmVkID0gZmxhZ3MuaW5kZXhPZignPCcpID49IDA7XG4gIHRoaXMub3B0aW9uYWwgPSBmbGFncy5pbmRleE9mKCdbJykgPj0gMDtcbiAgdGhpcy5ib29sID0gZmxhZ3MuaW5kZXhPZignLW5vLScpID09PSAtMTtcbiAgZmxhZ3MgPSBmbGFncy5zcGxpdCgvWyAsfF0rLyk7XG4gIGlmIChmbGFncy5sZW5ndGggPiAxICYmICEvXltbPF0vLnRlc3QoZmxhZ3NbMV0pKSB0aGlzLnNob3J0ID0gZmxhZ3Muc2hpZnQoKTtcbiAgdGhpcy5sb25nID0gZmxhZ3Muc2hpZnQoKTtcbiAgdGhpcy5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uIHx8ICcnO1xufVxuXG4vKipcbiAqIFJldHVybiBvcHRpb24gbmFtZS5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5PcHRpb24ucHJvdG90eXBlLm5hbWUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubG9uZ1xuICAgIC5yZXBsYWNlKCctLScsICcnKVxuICAgIC5yZXBsYWNlKCduby0nLCAnJyk7XG59O1xuXG4vKipcbiAqIFJldHVybiBvcHRpb24gbmFtZSwgaW4gYSBjYW1lbGNhc2UgZm9ybWF0IHRoYXQgY2FuIGJlIHVzZWRcbiAqIGFzIGEgb2JqZWN0IGF0dHJpYnV0ZSBrZXkuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuT3B0aW9uLnByb3RvdHlwZS5hdHRyaWJ1dGVOYW1lID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBjYW1lbGNhc2UodGhpcy5uYW1lKCkpO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgYXJnYCBtYXRjaGVzIHRoZSBzaG9ydCBvciBsb25nIGZsYWcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFyZ1xuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk9wdGlvbi5wcm90b3R5cGUuaXMgPSBmdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHRoaXMuc2hvcnQgPT09IGFyZyB8fCB0aGlzLmxvbmcgPT09IGFyZztcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgQ29tbWFuZGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gQ29tbWFuZChuYW1lKSB7XG4gIHRoaXMuY29tbWFuZHMgPSBbXTtcbiAgdGhpcy5vcHRpb25zID0gW107XG4gIHRoaXMuX2V4ZWNzID0ge307XG4gIHRoaXMuX2FsbG93VW5rbm93bk9wdGlvbiA9IGZhbHNlO1xuICB0aGlzLl9hcmdzID0gW107XG4gIHRoaXMuX25hbWUgPSBuYW1lIHx8ICcnO1xufVxuXG4vKipcbiAqIEFkZCBjb21tYW5kIGBuYW1lYC5cbiAqXG4gKiBUaGUgYC5hY3Rpb24oKWAgY2FsbGJhY2sgaXMgaW52b2tlZCB3aGVuIHRoZVxuICogY29tbWFuZCBgbmFtZWAgaXMgc3BlY2lmaWVkIHZpYSBfX0FSR1ZfXyxcbiAqIGFuZCB0aGUgcmVtYWluaW5nIGFyZ3VtZW50cyBhcmUgYXBwbGllZCB0byB0aGVcbiAqIGZ1bmN0aW9uIGZvciBhY2Nlc3MuXG4gKlxuICogV2hlbiB0aGUgYG5hbWVgIGlzIFwiKlwiIGFuIHVuLW1hdGNoZWQgY29tbWFuZFxuICogd2lsbCBiZSBwYXNzZWQgYXMgdGhlIGZpcnN0IGFyZywgZm9sbG93ZWQgYnlcbiAqIHRoZSByZXN0IG9mIF9fQVJHVl9fIHJlbWFpbmluZy5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHByb2dyYW1cbiAqICAgICAgICAudmVyc2lvbignMC4wLjEnKVxuICogICAgICAgIC5vcHRpb24oJy1DLCAtLWNoZGlyIDxwYXRoPicsICdjaGFuZ2UgdGhlIHdvcmtpbmcgZGlyZWN0b3J5JylcbiAqICAgICAgICAub3B0aW9uKCctYywgLS1jb25maWcgPHBhdGg+JywgJ3NldCBjb25maWcgcGF0aC4gZGVmYXVsdHMgdG8gLi9kZXBsb3kuY29uZicpXG4gKiAgICAgICAgLm9wdGlvbignLVQsIC0tbm8tdGVzdHMnLCAnaWdub3JlIHRlc3QgaG9vaycpXG4gKlxuICogICAgICBwcm9ncmFtXG4gKiAgICAgICAgLmNvbW1hbmQoJ3NldHVwJylcbiAqICAgICAgICAuZGVzY3JpcHRpb24oJ3J1biByZW1vdGUgc2V0dXAgY29tbWFuZHMnKVxuICogICAgICAgIC5hY3Rpb24oZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgICBjb25zb2xlLmxvZygnc2V0dXAnKTtcbiAqICAgICAgICB9KTtcbiAqXG4gKiAgICAgIHByb2dyYW1cbiAqICAgICAgICAuY29tbWFuZCgnZXhlYyA8Y21kPicpXG4gKiAgICAgICAgLmRlc2NyaXB0aW9uKCdydW4gdGhlIGdpdmVuIHJlbW90ZSBjb21tYW5kJylcbiAqICAgICAgICAuYWN0aW9uKGZ1bmN0aW9uKGNtZCkge1xuICogICAgICAgICAgY29uc29sZS5sb2coJ2V4ZWMgXCIlc1wiJywgY21kKTtcbiAqICAgICAgICB9KTtcbiAqXG4gKiAgICAgIHByb2dyYW1cbiAqICAgICAgICAuY29tbWFuZCgndGVhcmRvd24gPGRpcj4gW290aGVyRGlycy4uLl0nKVxuICogICAgICAgIC5kZXNjcmlwdGlvbigncnVuIHRlYXJkb3duIGNvbW1hbmRzJylcbiAqICAgICAgICAuYWN0aW9uKGZ1bmN0aW9uKGRpciwgb3RoZXJEaXJzKSB7XG4gKiAgICAgICAgICBjb25zb2xlLmxvZygnZGlyIFwiJXNcIicsIGRpcik7XG4gKiAgICAgICAgICBpZiAob3RoZXJEaXJzKSB7XG4gKiAgICAgICAgICAgIG90aGVyRGlycy5mb3JFYWNoKGZ1bmN0aW9uIChvRGlyKSB7XG4gKiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2RpciBcIiVzXCInLCBvRGlyKTtcbiAqICAgICAgICAgICAgfSk7XG4gKiAgICAgICAgICB9XG4gKiAgICAgICAgfSk7XG4gKlxuICogICAgICBwcm9ncmFtXG4gKiAgICAgICAgLmNvbW1hbmQoJyonKVxuICogICAgICAgIC5kZXNjcmlwdGlvbignZGVwbG95IHRoZSBnaXZlbiBlbnYnKVxuICogICAgICAgIC5hY3Rpb24oZnVuY3Rpb24oZW52KSB7XG4gKiAgICAgICAgICBjb25zb2xlLmxvZygnZGVwbG95aW5nIFwiJXNcIicsIGVudik7XG4gKiAgICAgICAgfSk7XG4gKlxuICogICAgICBwcm9ncmFtLnBhcnNlKHByb2Nlc3MuYXJndik7XG4gICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gW2Rlc2NdIGZvciBnaXQtc3R5bGUgc3ViLWNvbW1hbmRzXG4gKiBAcmV0dXJuIHtDb21tYW5kfSB0aGUgbmV3IGNvbW1hbmRcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUuY29tbWFuZCA9IGZ1bmN0aW9uKG5hbWUsIGRlc2MsIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiBkZXNjID09PSAnb2JqZWN0JyAmJiBkZXNjICE9PSBudWxsKSB7XG4gICAgb3B0cyA9IGRlc2M7XG4gICAgZGVzYyA9IG51bGw7XG4gIH1cbiAgb3B0cyA9IG9wdHMgfHwge307XG4gIHZhciBhcmdzID0gbmFtZS5zcGxpdCgvICsvKTtcbiAgdmFyIGNtZCA9IG5ldyBDb21tYW5kKGFyZ3Muc2hpZnQoKSk7XG5cbiAgaWYgKGRlc2MpIHtcbiAgICBjbWQuZGVzY3JpcHRpb24oZGVzYyk7XG4gICAgdGhpcy5leGVjdXRhYmxlcyA9IHRydWU7XG4gICAgdGhpcy5fZXhlY3NbY21kLl9uYW1lXSA9IHRydWU7XG4gICAgaWYgKG9wdHMuaXNEZWZhdWx0KSB0aGlzLmRlZmF1bHRFeGVjdXRhYmxlID0gY21kLl9uYW1lO1xuICB9XG4gIGNtZC5fbm9IZWxwID0gISFvcHRzLm5vSGVscDtcbiAgdGhpcy5jb21tYW5kcy5wdXNoKGNtZCk7XG4gIGNtZC5wYXJzZUV4cGVjdGVkQXJncyhhcmdzKTtcbiAgY21kLnBhcmVudCA9IHRoaXM7XG5cbiAgaWYgKGRlc2MpIHJldHVybiB0aGlzO1xuICByZXR1cm4gY21kO1xufTtcblxuLyoqXG4gKiBEZWZpbmUgYXJndW1lbnQgc3ludGF4IGZvciB0aGUgdG9wLWxldmVsIGNvbW1hbmQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db21tYW5kLnByb3RvdHlwZS5hcmd1bWVudHMgPSBmdW5jdGlvbihkZXNjKSB7XG4gIHJldHVybiB0aGlzLnBhcnNlRXhwZWN0ZWRBcmdzKGRlc2Muc3BsaXQoLyArLykpO1xufTtcblxuLyoqXG4gKiBBZGQgYW4gaW1wbGljaXQgYGhlbHAgW2NtZF1gIHN1YmNvbW1hbmRcbiAqIHdoaWNoIGludm9rZXMgYC0taGVscGAgZm9yIHRoZSBnaXZlbiBjb21tYW5kLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbW1hbmQucHJvdG90eXBlLmFkZEltcGxpY2l0SGVscENvbW1hbmQgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5jb21tYW5kKCdoZWxwIFtjbWRdJywgJ2Rpc3BsYXkgaGVscCBmb3IgW2NtZF0nKTtcbn07XG5cbi8qKlxuICogUGFyc2UgZXhwZWN0ZWQgYGFyZ3NgLlxuICpcbiAqIEZvciBleGFtcGxlIGBbXCJbdHlwZV1cIl1gIGJlY29tZXMgYFt7IHJlcXVpcmVkOiBmYWxzZSwgbmFtZTogJ3R5cGUnIH1dYC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzXG4gKiBAcmV0dXJuIHtDb21tYW5kfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUucGFyc2VFeHBlY3RlZEFyZ3MgPSBmdW5jdGlvbihhcmdzKSB7XG4gIGlmICghYXJncy5sZW5ndGgpIHJldHVybjtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBhcmdzLmZvckVhY2goZnVuY3Rpb24oYXJnKSB7XG4gICAgdmFyIGFyZ0RldGFpbHMgPSB7XG4gICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICBuYW1lOiAnJyxcbiAgICAgIHZhcmlhZGljOiBmYWxzZVxuICAgIH07XG5cbiAgICBzd2l0Y2ggKGFyZ1swXSkge1xuICAgICAgY2FzZSAnPCc6XG4gICAgICAgIGFyZ0RldGFpbHMucmVxdWlyZWQgPSB0cnVlO1xuICAgICAgICBhcmdEZXRhaWxzLm5hbWUgPSBhcmcuc2xpY2UoMSwgLTEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1snOlxuICAgICAgICBhcmdEZXRhaWxzLm5hbWUgPSBhcmcuc2xpY2UoMSwgLTEpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoYXJnRGV0YWlscy5uYW1lLmxlbmd0aCA+IDMgJiYgYXJnRGV0YWlscy5uYW1lLnNsaWNlKC0zKSA9PT0gJy4uLicpIHtcbiAgICAgIGFyZ0RldGFpbHMudmFyaWFkaWMgPSB0cnVlO1xuICAgICAgYXJnRGV0YWlscy5uYW1lID0gYXJnRGV0YWlscy5uYW1lLnNsaWNlKDAsIC0zKTtcbiAgICB9XG4gICAgaWYgKGFyZ0RldGFpbHMubmFtZSkge1xuICAgICAgc2VsZi5fYXJncy5wdXNoKGFyZ0RldGFpbHMpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlciBjYWxsYmFjayBgZm5gIGZvciB0aGUgY29tbWFuZC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHByb2dyYW1cbiAqICAgICAgICAuY29tbWFuZCgnaGVscCcpXG4gKiAgICAgICAgLmRlc2NyaXB0aW9uKCdkaXNwbGF5IHZlcmJvc2UgaGVscCcpXG4gKiAgICAgICAgLmFjdGlvbihmdW5jdGlvbigpIHtcbiAqICAgICAgICAgICAvLyBvdXRwdXQgaGVscCBoZXJlXG4gKiAgICAgICAgfSk7XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0NvbW1hbmR9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Db21tYW5kLnByb3RvdHlwZS5hY3Rpb24gPSBmdW5jdGlvbihmbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uKGFyZ3MsIHVua25vd24pIHtcbiAgICAvLyBQYXJzZSBhbnkgc28tZmFyIHVua25vd24gb3B0aW9uc1xuICAgIGFyZ3MgPSBhcmdzIHx8IFtdO1xuICAgIHVua25vd24gPSB1bmtub3duIHx8IFtdO1xuXG4gICAgdmFyIHBhcnNlZCA9IHNlbGYucGFyc2VPcHRpb25zKHVua25vd24pO1xuXG4gICAgLy8gT3V0cHV0IGhlbHAgaWYgbmVjZXNzYXJ5XG4gICAgb3V0cHV0SGVscElmTmVjZXNzYXJ5KHNlbGYsIHBhcnNlZC51bmtub3duKTtcblxuICAgIC8vIElmIHRoZXJlIGFyZSBzdGlsbCBhbnkgdW5rbm93biBvcHRpb25zLCB0aGVuIHdlIHNpbXBseVxuICAgIC8vIGRpZSwgdW5sZXNzIHNvbWVvbmUgYXNrZWQgZm9yIGhlbHAsIGluIHdoaWNoIGNhc2Ugd2UgZ2l2ZSBpdFxuICAgIC8vIHRvIHRoZW0sIGFuZCB0aGVuIHdlIGRpZS5cbiAgICBpZiAocGFyc2VkLnVua25vd24ubGVuZ3RoID4gMCkge1xuICAgICAgc2VsZi51bmtub3duT3B0aW9uKHBhcnNlZC51bmtub3duWzBdKTtcbiAgICB9XG5cbiAgICAvLyBMZWZ0b3ZlciBhcmd1bWVudHMgbmVlZCB0byBiZSBwdXNoZWQgYmFjay4gRml4ZXMgaXNzdWUgIzU2XG4gICAgaWYgKHBhcnNlZC5hcmdzLmxlbmd0aCkgYXJncyA9IHBhcnNlZC5hcmdzLmNvbmNhdChhcmdzKTtcblxuICAgIHNlbGYuX2FyZ3MuZm9yRWFjaChmdW5jdGlvbihhcmcsIGkpIHtcbiAgICAgIGlmIChhcmcucmVxdWlyZWQgJiYgYXJnc1tpXSA9PSBudWxsKSB7XG4gICAgICAgIHNlbGYubWlzc2luZ0FyZ3VtZW50KGFyZy5uYW1lKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJnLnZhcmlhZGljKSB7XG4gICAgICAgIGlmIChpICE9PSBzZWxmLl9hcmdzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBzZWxmLnZhcmlhZGljQXJnTm90TGFzdChhcmcubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBhcmdzW2ldID0gYXJncy5zcGxpY2UoaSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBBbHdheXMgYXBwZW5kIG91cnNlbHZlcyB0byB0aGUgZW5kIG9mIHRoZSBhcmd1bWVudHMsXG4gICAgLy8gdG8gbWFrZSBzdXJlIHdlIG1hdGNoIHRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHRoZSB1c2VyXG4gICAgLy8gZXhwZWN0c1xuICAgIGlmIChzZWxmLl9hcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tzZWxmLl9hcmdzLmxlbmd0aF0gPSBzZWxmO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcmdzLnB1c2goc2VsZik7XG4gICAgfVxuXG4gICAgZm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gIH07XG4gIHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudCB8fCB0aGlzO1xuICB2YXIgbmFtZSA9IHBhcmVudCA9PT0gdGhpcyA/ICcqJyA6IHRoaXMuX25hbWU7XG4gIHBhcmVudC5vbignY29tbWFuZDonICsgbmFtZSwgbGlzdGVuZXIpO1xuICBpZiAodGhpcy5fYWxpYXMpIHBhcmVudC5vbignY29tbWFuZDonICsgdGhpcy5fYWxpYXMsIGxpc3RlbmVyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIERlZmluZSBvcHRpb24gd2l0aCBgZmxhZ3NgLCBgZGVzY3JpcHRpb25gIGFuZCBvcHRpb25hbFxuICogY29lcmNpb24gYGZuYC5cbiAqXG4gKiBUaGUgYGZsYWdzYCBzdHJpbmcgc2hvdWxkIGNvbnRhaW4gYm90aCB0aGUgc2hvcnQgYW5kIGxvbmcgZmxhZ3MsXG4gKiBzZXBhcmF0ZWQgYnkgY29tbWEsIGEgcGlwZSBvciBzcGFjZS4gVGhlIGZvbGxvd2luZyBhcmUgYWxsIHZhbGlkXG4gKiBhbGwgd2lsbCBvdXRwdXQgdGhpcyB3YXkgd2hlbiBgLS1oZWxwYCBpcyB1c2VkLlxuICpcbiAqICAgIFwiLXAsIC0tcGVwcGVyXCJcbiAqICAgIFwiLXB8LS1wZXBwZXJcIlxuICogICAgXCItcCAtLXBlcHBlclwiXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgIC8vIHNpbXBsZSBib29sZWFuIGRlZmF1bHRpbmcgdG8gZmFsc2VcbiAqICAgICBwcm9ncmFtLm9wdGlvbignLXAsIC0tcGVwcGVyJywgJ2FkZCBwZXBwZXInKTtcbiAqXG4gKiAgICAgLS1wZXBwZXJcbiAqICAgICBwcm9ncmFtLnBlcHBlclxuICogICAgIC8vID0+IEJvb2xlYW5cbiAqXG4gKiAgICAgLy8gc2ltcGxlIGJvb2xlYW4gZGVmYXVsdGluZyB0byB0cnVlXG4gKiAgICAgcHJvZ3JhbS5vcHRpb24oJy1DLCAtLW5vLWNoZWVzZScsICdyZW1vdmUgY2hlZXNlJyk7XG4gKlxuICogICAgIHByb2dyYW0uY2hlZXNlXG4gKiAgICAgLy8gPT4gdHJ1ZVxuICpcbiAqICAgICAtLW5vLWNoZWVzZVxuICogICAgIHByb2dyYW0uY2hlZXNlXG4gKiAgICAgLy8gPT4gZmFsc2VcbiAqXG4gKiAgICAgLy8gcmVxdWlyZWQgYXJndW1lbnRcbiAqICAgICBwcm9ncmFtLm9wdGlvbignLUMsIC0tY2hkaXIgPHBhdGg+JywgJ2NoYW5nZSB0aGUgd29ya2luZyBkaXJlY3RvcnknKTtcbiAqXG4gKiAgICAgLS1jaGRpciAvdG1wXG4gKiAgICAgcHJvZ3JhbS5jaGRpclxuICogICAgIC8vID0+IFwiL3RtcFwiXG4gKlxuICogICAgIC8vIG9wdGlvbmFsIGFyZ3VtZW50XG4gKiAgICAgcHJvZ3JhbS5vcHRpb24oJy1jLCAtLWNoZWVzZSBbdHlwZV0nLCAnYWRkIGNoZWVzZSBbbWFyYmxlXScpO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmbGFnc1xuICogQHBhcmFtIHtTdHJpbmd9IGRlc2NyaXB0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufCp9IFtmbl0gb3IgZGVmYXVsdFxuICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXVxuICogQHJldHVybiB7Q29tbWFuZH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbW1hbmQucHJvdG90eXBlLm9wdGlvbiA9IGZ1bmN0aW9uKGZsYWdzLCBkZXNjcmlwdGlvbiwgZm4sIGRlZmF1bHRWYWx1ZSkge1xuICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgb3B0aW9uID0gbmV3IE9wdGlvbihmbGFncywgZGVzY3JpcHRpb24pLFxuICAgIG9uYW1lID0gb3B0aW9uLm5hbWUoKSxcbiAgICBuYW1lID0gb3B0aW9uLmF0dHJpYnV0ZU5hbWUoKTtcblxuICAvLyBkZWZhdWx0IGFzIDNyZCBhcmdcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgdmFyIHJlZ2V4ID0gZm47XG4gICAgICBmbiA9IGZ1bmN0aW9uKHZhbCwgZGVmKSB7XG4gICAgICAgIHZhciBtID0gcmVnZXguZXhlYyh2YWwpO1xuICAgICAgICByZXR1cm4gbSA/IG1bMF0gOiBkZWY7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSBmbjtcbiAgICAgIGZuID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICAvLyBwcmVhc3NpZ24gZGVmYXVsdCB2YWx1ZSBvbmx5IGZvciAtLW5vLSosIFtvcHRpb25hbF0sIG9yIDxyZXF1aXJlZD5cbiAgaWYgKCFvcHRpb24uYm9vbCB8fCBvcHRpb24ub3B0aW9uYWwgfHwgb3B0aW9uLnJlcXVpcmVkKSB7XG4gICAgLy8gd2hlbiAtLW5vLSogd2UgbWFrZSBzdXJlIGRlZmF1bHQgaXMgdHJ1ZVxuICAgIGlmICghb3B0aW9uLmJvb2wpIGRlZmF1bHRWYWx1ZSA9IHRydWU7XG4gICAgLy8gcHJlYXNzaWduIG9ubHkgaWYgd2UgaGF2ZSBhIGRlZmF1bHRcbiAgICBpZiAoZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNlbGZbbmFtZV0gPSBkZWZhdWx0VmFsdWU7XG4gICAgICBvcHRpb24uZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJlZ2lzdGVyIHRoZSBvcHRpb25cbiAgdGhpcy5vcHRpb25zLnB1c2gob3B0aW9uKTtcblxuICAvLyB3aGVuIGl0J3MgcGFzc2VkIGFzc2lnbiB0aGUgdmFsdWVcbiAgLy8gYW5kIGNvbmRpdGlvbmFsbHkgaW52b2tlIHRoZSBjYWxsYmFja1xuICB0aGlzLm9uKCdvcHRpb246JyArIG9uYW1lLCBmdW5jdGlvbih2YWwpIHtcbiAgICAvLyBjb2VyY2lvblxuICAgIGlmICh2YWwgIT09IG51bGwgJiYgZm4pIHtcbiAgICAgIHZhbCA9IGZuKHZhbCwgc2VsZltuYW1lXSA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogc2VsZltuYW1lXSk7XG4gICAgfVxuXG4gICAgLy8gdW5hc3NpZ25lZCBvciBib29sXG4gICAgaWYgKHR5cGVvZiBzZWxmW25hbWVdID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHNlbGZbbmFtZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAvLyBpZiBubyB2YWx1ZSwgYm9vbCB0cnVlLCBhbmQgd2UgaGF2ZSBhIGRlZmF1bHQsIHRoZW4gdXNlIGl0IVxuICAgICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgIHNlbGZbbmFtZV0gPSBvcHRpb24uYm9vbFxuICAgICAgICAgID8gZGVmYXVsdFZhbHVlIHx8IHRydWVcbiAgICAgICAgICA6IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZltuYW1lXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZhbCAhPT0gbnVsbCkge1xuICAgICAgLy8gcmVhc3NpZ25cbiAgICAgIHNlbGZbbmFtZV0gPSB2YWw7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWxsb3cgdW5rbm93biBvcHRpb25zIG9uIHRoZSBjb21tYW5kIGxpbmUuXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBhcmcgaWYgYHRydWVgIG9yIG9taXR0ZWQsIG5vIGVycm9yIHdpbGwgYmUgdGhyb3duXG4gKiBmb3IgdW5rbm93biBvcHRpb25zLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuQ29tbWFuZC5wcm90b3R5cGUuYWxsb3dVbmtub3duT3B0aW9uID0gZnVuY3Rpb24oYXJnKSB7XG4gIHRoaXMuX2FsbG93VW5rbm93bk9wdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDAgfHwgYXJnO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUGFyc2UgYGFyZ3ZgLCBzZXR0aW5ncyBvcHRpb25zIGFuZCBpbnZva2luZyBjb21tYW5kcyB3aGVuIGRlZmluZWQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJndlxuICogQHJldHVybiB7Q29tbWFuZH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbW1hbmQucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oYXJndikge1xuICAvLyBpbXBsaWNpdCBoZWxwXG4gIGlmICh0aGlzLmV4ZWN1dGFibGVzKSB0aGlzLmFkZEltcGxpY2l0SGVscENvbW1hbmQoKTtcblxuICAvLyBzdG9yZSByYXcgYXJnc1xuICB0aGlzLnJhd0FyZ3MgPSBhcmd2O1xuXG4gIC8vIGd1ZXNzIG5hbWVcbiAgdGhpcy5fbmFtZSA9IHRoaXMuX25hbWUgfHwgYmFzZW5hbWUoYXJndlsxXSwgJy5qcycpO1xuXG4gIC8vIGdpdGh1Yi1zdHlsZSBzdWItY29tbWFuZHMgd2l0aCBubyBzdWItY29tbWFuZFxuICBpZiAodGhpcy5leGVjdXRhYmxlcyAmJiBhcmd2Lmxlbmd0aCA8IDMgJiYgIXRoaXMuZGVmYXVsdEV4ZWN1dGFibGUpIHtcbiAgICAvLyB0aGlzIHVzZXIgbmVlZHMgaGVscFxuICAgIGFyZ3YucHVzaCgnLS1oZWxwJyk7XG4gIH1cblxuICAvLyBwcm9jZXNzIGFyZ3ZcbiAgdmFyIHBhcnNlZCA9IHRoaXMucGFyc2VPcHRpb25zKHRoaXMubm9ybWFsaXplKGFyZ3Yuc2xpY2UoMikpKTtcbiAgdmFyIGFyZ3MgPSB0aGlzLmFyZ3MgPSBwYXJzZWQuYXJncztcblxuICB2YXIgcmVzdWx0ID0gdGhpcy5wYXJzZUFyZ3ModGhpcy5hcmdzLCBwYXJzZWQudW5rbm93bik7XG5cbiAgLy8gZXhlY3V0YWJsZSBzdWItY29tbWFuZHNcbiAgdmFyIG5hbWUgPSByZXN1bHQuYXJnc1swXTtcblxuICB2YXIgYWxpYXNDb21tYW5kID0gbnVsbDtcbiAgLy8gY2hlY2sgYWxpYXMgb2Ygc3ViIGNvbW1hbmRzXG4gIGlmIChuYW1lKSB7XG4gICAgYWxpYXNDb21tYW5kID0gdGhpcy5jb21tYW5kcy5maWx0ZXIoZnVuY3Rpb24oY29tbWFuZCkge1xuICAgICAgcmV0dXJuIGNvbW1hbmQuYWxpYXMoKSA9PT0gbmFtZTtcbiAgICB9KVswXTtcbiAgfVxuXG4gIGlmICh0aGlzLl9leGVjc1tuYW1lXSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGVTdWJDb21tYW5kKGFyZ3YsIGFyZ3MsIHBhcnNlZC51bmtub3duKTtcbiAgfSBlbHNlIGlmIChhbGlhc0NvbW1hbmQpIHtcbiAgICAvLyBpcyBhbGlhcyBvZiBhIHN1YkNvbW1hbmRcbiAgICBhcmdzWzBdID0gYWxpYXNDb21tYW5kLl9uYW1lO1xuICAgIHJldHVybiB0aGlzLmV4ZWN1dGVTdWJDb21tYW5kKGFyZ3YsIGFyZ3MsIHBhcnNlZC51bmtub3duKTtcbiAgfSBlbHNlIGlmICh0aGlzLmRlZmF1bHRFeGVjdXRhYmxlKSB7XG4gICAgLy8gdXNlIHRoZSBkZWZhdWx0IHN1YmNvbW1hbmRcbiAgICBhcmdzLnVuc2hpZnQodGhpcy5kZWZhdWx0RXhlY3V0YWJsZSk7XG4gICAgcmV0dXJuIHRoaXMuZXhlY3V0ZVN1YkNvbW1hbmQoYXJndiwgYXJncywgcGFyc2VkLnVua25vd24pO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogRXhlY3V0ZSBhIHN1Yi1jb21tYW5kIGV4ZWN1dGFibGUuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJndlxuICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICogQHBhcmFtIHtBcnJheX0gdW5rbm93blxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUuZXhlY3V0ZVN1YkNvbW1hbmQgPSBmdW5jdGlvbihhcmd2LCBhcmdzLCB1bmtub3duKSB7XG4gIGFyZ3MgPSBhcmdzLmNvbmNhdCh1bmtub3duKTtcblxuICBpZiAoIWFyZ3MubGVuZ3RoKSB0aGlzLmhlbHAoKTtcbiAgaWYgKGFyZ3NbMF0gPT09ICdoZWxwJyAmJiBhcmdzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWxwKCk7XG5cbiAgLy8gPGNtZD4gLS1oZWxwXG4gIGlmIChhcmdzWzBdID09PSAnaGVscCcpIHtcbiAgICBhcmdzWzBdID0gYXJnc1sxXTtcbiAgICBhcmdzWzFdID0gJy0taGVscCc7XG4gIH1cblxuICAvLyBleGVjdXRhYmxlXG4gIHZhciBmID0gYXJndlsxXTtcbiAgLy8gbmFtZSBvZiB0aGUgc3ViY29tbWFuZCwgbGluayBgcG0taW5zdGFsbGBcbiAgdmFyIGJpbiA9IGJhc2VuYW1lKGYsIHBhdGguZXh0bmFtZShmKSkgKyAnLScgKyBhcmdzWzBdO1xuXG4gIC8vIEluIGNhc2Ugb2YgZ2xvYmFsbHkgaW5zdGFsbGVkLCBnZXQgdGhlIGJhc2UgZGlyIHdoZXJlIGV4ZWN1dGFibGVcbiAgLy8gIHN1YmNvbW1hbmQgZmlsZSBzaG91bGQgYmUgbG9jYXRlZCBhdFxuICB2YXIgYmFzZURpcjtcblxuICB2YXIgcmVzb2x2ZWRMaW5rID0gZnMucmVhbHBhdGhTeW5jKGYpO1xuXG4gIGJhc2VEaXIgPSBkaXJuYW1lKHJlc29sdmVkTGluayk7XG5cbiAgLy8gcHJlZmVyIGxvY2FsIGAuLzxiaW4+YCB0byBiaW4gaW4gdGhlICRQQVRIXG4gIHZhciBsb2NhbEJpbiA9IHBhdGguam9pbihiYXNlRGlyLCBiaW4pO1xuXG4gIC8vIHdoZXRoZXIgYmluIGZpbGUgaXMgYSBqcyBzY3JpcHQgd2l0aCBleHBsaWNpdCBgLmpzYCBvciBgLnRzYCBleHRlbnNpb25cbiAgdmFyIGlzRXhwbGljaXRKUyA9IGZhbHNlO1xuICBpZiAoZXhpc3RzKGxvY2FsQmluICsgJy5qcycpKSB7XG4gICAgYmluID0gbG9jYWxCaW4gKyAnLmpzJztcbiAgICBpc0V4cGxpY2l0SlMgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGV4aXN0cyhsb2NhbEJpbiArICcudHMnKSkge1xuICAgIGJpbiA9IGxvY2FsQmluICsgJy50cyc7XG4gICAgaXNFeHBsaWNpdEpTID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChleGlzdHMobG9jYWxCaW4pKSB7XG4gICAgYmluID0gbG9jYWxCaW47XG4gIH1cblxuICBhcmdzID0gYXJncy5zbGljZSgxKTtcblxuICB2YXIgcHJvYztcbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gIT09ICd3aW4zMicpIHtcbiAgICBpZiAoaXNFeHBsaWNpdEpTKSB7XG4gICAgICBhcmdzLnVuc2hpZnQoYmluKTtcbiAgICAgIC8vIGFkZCBleGVjdXRhYmxlIGFyZ3VtZW50cyB0byBzcGF3blxuICAgICAgYXJncyA9IChwcm9jZXNzLmV4ZWNBcmd2IHx8IFtdKS5jb25jYXQoYXJncyk7XG5cbiAgICAgIHByb2MgPSBzcGF3bihwcm9jZXNzLmFyZ3ZbMF0sIGFyZ3MsIHsgc3RkaW86ICdpbmhlcml0JywgY3VzdG9tRmRzOiBbMCwgMSwgMl0gfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2MgPSBzcGF3bihiaW4sIGFyZ3MsIHsgc3RkaW86ICdpbmhlcml0JywgY3VzdG9tRmRzOiBbMCwgMSwgMl0gfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGFyZ3MudW5zaGlmdChiaW4pO1xuICAgIHByb2MgPSBzcGF3bihwcm9jZXNzLmV4ZWNQYXRoLCBhcmdzLCB7IHN0ZGlvOiAnaW5oZXJpdCcgfSk7XG4gIH1cblxuICB2YXIgc2lnbmFscyA9IFsnU0lHVVNSMScsICdTSUdVU1IyJywgJ1NJR1RFUk0nLCAnU0lHSU5UJywgJ1NJR0hVUCddO1xuICBzaWduYWxzLmZvckVhY2goZnVuY3Rpb24oc2lnbmFsKSB7XG4gICAgcHJvY2Vzcy5vbihzaWduYWwsIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHByb2Mua2lsbGVkID09PSBmYWxzZSAmJiBwcm9jLmV4aXRDb2RlID09PSBudWxsKSB7XG4gICAgICAgIHByb2Mua2lsbChzaWduYWwpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcHJvYy5vbignY2xvc2UnLCBwcm9jZXNzLmV4aXQuYmluZChwcm9jZXNzKSk7XG4gIHByb2Mub24oJ2Vycm9yJywgZnVuY3Rpb24oZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgY29uc29sZS5lcnJvcignZXJyb3I6ICVzKDEpIGRvZXMgbm90IGV4aXN0LCB0cnkgLS1oZWxwJywgYmluKTtcbiAgICB9IGVsc2UgaWYgKGVyci5jb2RlID09PSAnRUFDQ0VTJykge1xuICAgICAgY29uc29sZS5lcnJvcignZXJyb3I6ICVzKDEpIG5vdCBleGVjdXRhYmxlLiB0cnkgY2htb2Qgb3IgcnVuIHdpdGggcm9vdCcsIGJpbik7XG4gICAgfVxuICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgfSk7XG5cbiAgLy8gU3RvcmUgdGhlIHJlZmVyZW5jZSB0byB0aGUgY2hpbGQgcHJvY2Vzc1xuICB0aGlzLnJ1bm5pbmdDb21tYW5kID0gcHJvYztcbn07XG5cbi8qKlxuICogTm9ybWFsaXplIGBhcmdzYCwgc3BsaXR0aW5nIGpvaW5lZCBzaG9ydCBmbGFncy4gRm9yIGV4YW1wbGVcbiAqIHRoZSBhcmcgXCItYWJjXCIgaXMgZXF1aXZhbGVudCB0byBcIi1hIC1iIC1jXCIuXG4gKiBUaGlzIGFsc28gbm9ybWFsaXplcyBlcXVhbCBzaWduIGFuZCBzcGxpdHMgXCItLWFiYz1kZWZcIiBpbnRvIFwiLS1hYmMgZGVmXCIuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJnc1xuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db21tYW5kLnByb3RvdHlwZS5ub3JtYWxpemUgPSBmdW5jdGlvbihhcmdzKSB7XG4gIHZhciByZXQgPSBbXSxcbiAgICBhcmcsXG4gICAgbGFzdE9wdCxcbiAgICBpbmRleDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJncy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGFyZyA9IGFyZ3NbaV07XG4gICAgaWYgKGkgPiAwKSB7XG4gICAgICBsYXN0T3B0ID0gdGhpcy5vcHRpb25Gb3IoYXJnc1tpIC0gMV0pO1xuICAgIH1cblxuICAgIGlmIChhcmcgPT09ICctLScpIHtcbiAgICAgIC8vIEhvbm9yIG9wdGlvbiB0ZXJtaW5hdG9yXG4gICAgICByZXQgPSByZXQuY29uY2F0KGFyZ3Muc2xpY2UoaSkpO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChsYXN0T3B0ICYmIGxhc3RPcHQucmVxdWlyZWQpIHtcbiAgICAgIHJldC5wdXNoKGFyZyk7XG4gICAgfSBlbHNlIGlmIChhcmcubGVuZ3RoID4gMSAmJiBhcmdbMF0gPT09ICctJyAmJiBhcmdbMV0gIT09ICctJykge1xuICAgICAgYXJnLnNsaWNlKDEpLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcmV0LnB1c2goJy0nICsgYyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKC9eLS0vLnRlc3QoYXJnKSAmJiB+KGluZGV4ID0gYXJnLmluZGV4T2YoJz0nKSkpIHtcbiAgICAgIHJldC5wdXNoKGFyZy5zbGljZSgwLCBpbmRleCksIGFyZy5zbGljZShpbmRleCArIDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0LnB1c2goYXJnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuLyoqXG4gKiBQYXJzZSBjb21tYW5kIGBhcmdzYC5cbiAqXG4gKiBXaGVuIGxpc3RlbmVyKHMpIGFyZSBhdmFpbGFibGUgdGhvc2VcbiAqIGNhbGxiYWNrcyBhcmUgaW52b2tlZCwgb3RoZXJ3aXNlIHRoZSBcIipcIlxuICogZXZlbnQgaXMgZW1pdHRlZCBhbmQgdGhvc2UgYWN0aW9ucyBhcmUgaW52b2tlZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzXG4gKiBAcmV0dXJuIHtDb21tYW5kfSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbW1hbmQucHJvdG90eXBlLnBhcnNlQXJncyA9IGZ1bmN0aW9uKGFyZ3MsIHVua25vd24pIHtcbiAgdmFyIG5hbWU7XG5cbiAgaWYgKGFyZ3MubGVuZ3RoKSB7XG4gICAgbmFtZSA9IGFyZ3NbMF07XG4gICAgaWYgKHRoaXMubGlzdGVuZXJzKCdjb21tYW5kOicgKyBuYW1lKS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZW1pdCgnY29tbWFuZDonICsgYXJncy5zaGlmdCgpLCBhcmdzLCB1bmtub3duKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCdjb21tYW5kOionLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgb3V0cHV0SGVscElmTmVjZXNzYXJ5KHRoaXMsIHVua25vd24pO1xuXG4gICAgLy8gSWYgdGhlcmUgd2VyZSBubyBhcmdzIGFuZCB3ZSBoYXZlIHVua25vd24gb3B0aW9ucyxcbiAgICAvLyB0aGVuIHRoZXkgYXJlIGV4dHJhbmVvdXMgYW5kIHdlIG5lZWQgdG8gZXJyb3IuXG4gICAgaWYgKHVua25vd24ubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy51bmtub3duT3B0aW9uKHVua25vd25bMF0pO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb21tYW5kcy5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgdGhpcy5fYXJncy5maWx0ZXIoZnVuY3Rpb24oYSkgeyByZXR1cm4gYS5yZXF1aXJlZDsgfSkubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLmVtaXQoJ2NvbW1hbmQ6KicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYW4gb3B0aW9uIG1hdGNoaW5nIGBhcmdgIGlmIGFueS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYXJnXG4gKiBAcmV0dXJuIHtPcHRpb259XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db21tYW5kLnByb3RvdHlwZS5vcHRpb25Gb3IgPSBmdW5jdGlvbihhcmcpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMub3B0aW9ucy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzLm9wdGlvbnNbaV0uaXMoYXJnKSkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9uc1tpXTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogUGFyc2Ugb3B0aW9ucyBmcm9tIGBhcmd2YCByZXR1cm5pbmcgYGFyZ3ZgXG4gKiB2b2lkIG9mIHRoZXNlIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYXJndlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbW1hbmQucHJvdG90eXBlLnBhcnNlT3B0aW9ucyA9IGZ1bmN0aW9uKGFyZ3YpIHtcbiAgdmFyIGFyZ3MgPSBbXSxcbiAgICBsZW4gPSBhcmd2Lmxlbmd0aCxcbiAgICBsaXRlcmFsLFxuICAgIG9wdGlvbixcbiAgICBhcmc7XG5cbiAgdmFyIHVua25vd25PcHRpb25zID0gW107XG5cbiAgLy8gcGFyc2Ugb3B0aW9uc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgYXJnID0gYXJndltpXTtcblxuICAgIC8vIGxpdGVyYWwgYXJncyBhZnRlciAtLVxuICAgIGlmIChsaXRlcmFsKSB7XG4gICAgICBhcmdzLnB1c2goYXJnKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChhcmcgPT09ICctLScpIHtcbiAgICAgIGxpdGVyYWwgPSB0cnVlO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gZmluZCBtYXRjaGluZyBPcHRpb25cbiAgICBvcHRpb24gPSB0aGlzLm9wdGlvbkZvcihhcmcpO1xuXG4gICAgLy8gb3B0aW9uIGlzIGRlZmluZWRcbiAgICBpZiAob3B0aW9uKSB7XG4gICAgICAvLyByZXF1aXJlcyBhcmdcbiAgICAgIGlmIChvcHRpb24ucmVxdWlyZWQpIHtcbiAgICAgICAgYXJnID0gYXJndlsrK2ldO1xuICAgICAgICBpZiAoYXJnID09IG51bGwpIHJldHVybiB0aGlzLm9wdGlvbk1pc3NpbmdBcmd1bWVudChvcHRpb24pO1xuICAgICAgICB0aGlzLmVtaXQoJ29wdGlvbjonICsgb3B0aW9uLm5hbWUoKSwgYXJnKTtcbiAgICAgIC8vIG9wdGlvbmFsIGFyZ1xuICAgICAgfSBlbHNlIGlmIChvcHRpb24ub3B0aW9uYWwpIHtcbiAgICAgICAgYXJnID0gYXJndltpICsgMV07XG4gICAgICAgIGlmIChhcmcgPT0gbnVsbCB8fCAoYXJnWzBdID09PSAnLScgJiYgYXJnICE9PSAnLScpKSB7XG4gICAgICAgICAgYXJnID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICArK2k7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdvcHRpb246JyArIG9wdGlvbi5uYW1lKCksIGFyZyk7XG4gICAgICAvLyBib29sXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXQoJ29wdGlvbjonICsgb3B0aW9uLm5hbWUoKSk7XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBsb29rcyBsaWtlIGFuIG9wdGlvblxuICAgIGlmIChhcmcubGVuZ3RoID4gMSAmJiBhcmdbMF0gPT09ICctJykge1xuICAgICAgdW5rbm93bk9wdGlvbnMucHVzaChhcmcpO1xuXG4gICAgICAvLyBJZiB0aGUgbmV4dCBhcmd1bWVudCBsb29rcyBsaWtlIGl0IG1pZ2h0IGJlXG4gICAgICAvLyBhbiBhcmd1bWVudCBmb3IgdGhpcyBvcHRpb24sIHdlIHBhc3MgaXQgb24uXG4gICAgICAvLyBJZiBpdCBpc24ndCwgdGhlbiBpdCdsbCBzaW1wbHkgYmUgaWdub3JlZFxuICAgICAgaWYgKChpICsgMSkgPCBhcmd2Lmxlbmd0aCAmJiBhcmd2W2kgKyAxXVswXSAhPT0gJy0nKSB7XG4gICAgICAgIHVua25vd25PcHRpb25zLnB1c2goYXJndlsrK2ldKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIGFyZ1xuICAgIGFyZ3MucHVzaChhcmcpO1xuICB9XG5cbiAgcmV0dXJuIHsgYXJnczogYXJncywgdW5rbm93bjogdW5rbm93bk9wdGlvbnMgfTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGFuIG9iamVjdCBjb250YWluaW5nIG9wdGlvbnMgYXMga2V5LXZhbHVlIHBhaXJzXG4gKlxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuQ29tbWFuZC5wcm90b3R5cGUub3B0cyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVzdWx0ID0ge30sXG4gICAgbGVuID0gdGhpcy5vcHRpb25zLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGtleSA9IHRoaXMub3B0aW9uc1tpXS5hdHRyaWJ1dGVOYW1lKCk7XG4gICAgcmVzdWx0W2tleV0gPSBrZXkgPT09IHRoaXMuX3ZlcnNpb25PcHRpb25OYW1lID8gdGhpcy5fdmVyc2lvbiA6IHRoaXNba2V5XTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBBcmd1bWVudCBgbmFtZWAgaXMgbWlzc2luZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUubWlzc2luZ0FyZ3VtZW50ID0gZnVuY3Rpb24obmFtZSkge1xuICBjb25zb2xlLmVycm9yKFwiZXJyb3I6IG1pc3NpbmcgcmVxdWlyZWQgYXJndW1lbnQgYCVzJ1wiLCBuYW1lKTtcbiAgcHJvY2Vzcy5leGl0KDEpO1xufTtcblxuLyoqXG4gKiBgT3B0aW9uYCBpcyBtaXNzaW5nIGFuIGFyZ3VtZW50LCBidXQgcmVjZWl2ZWQgYGZsYWdgIG9yIG5vdGhpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvblxuICogQHBhcmFtIHtTdHJpbmd9IGZsYWdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbW1hbmQucHJvdG90eXBlLm9wdGlvbk1pc3NpbmdBcmd1bWVudCA9IGZ1bmN0aW9uKG9wdGlvbiwgZmxhZykge1xuICBpZiAoZmxhZykge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJlcnJvcjogb3B0aW9uIGAlcycgYXJndW1lbnQgbWlzc2luZywgZ290IGAlcydcIiwgb3B0aW9uLmZsYWdzLCBmbGFnKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zb2xlLmVycm9yKFwiZXJyb3I6IG9wdGlvbiBgJXMnIGFyZ3VtZW50IG1pc3NpbmdcIiwgb3B0aW9uLmZsYWdzKTtcbiAgfVxuICBwcm9jZXNzLmV4aXQoMSk7XG59O1xuXG4vKipcbiAqIFVua25vd24gb3B0aW9uIGBmbGFnYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmxhZ1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUudW5rbm93bk9wdGlvbiA9IGZ1bmN0aW9uKGZsYWcpIHtcbiAgaWYgKHRoaXMuX2FsbG93VW5rbm93bk9wdGlvbikgcmV0dXJuO1xuICBjb25zb2xlLmVycm9yKFwiZXJyb3I6IHVua25vd24gb3B0aW9uIGAlcydcIiwgZmxhZyk7XG4gIHByb2Nlc3MuZXhpdCgxKTtcbn07XG5cbi8qKlxuICogVmFyaWFkaWMgYXJndW1lbnQgd2l0aCBgbmFtZWAgaXMgbm90IHRoZSBsYXN0IGFyZ3VtZW50IGFzIHJlcXVpcmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db21tYW5kLnByb3RvdHlwZS52YXJpYWRpY0FyZ05vdExhc3QgPSBmdW5jdGlvbihuYW1lKSB7XG4gIGNvbnNvbGUuZXJyb3IoXCJlcnJvcjogdmFyaWFkaWMgYXJndW1lbnRzIG11c3QgYmUgbGFzdCBgJXMnXCIsIG5hbWUpO1xuICBwcm9jZXNzLmV4aXQoMSk7XG59O1xuXG4vKipcbiAqIFNldCB0aGUgcHJvZ3JhbSB2ZXJzaW9uIHRvIGBzdHJgLlxuICpcbiAqIFRoaXMgbWV0aG9kIGF1dG8tcmVnaXN0ZXJzIHRoZSBcIi1WLCAtLXZlcnNpb25cIiBmbGFnXG4gKiB3aGljaCB3aWxsIHByaW50IHRoZSB2ZXJzaW9uIG51bWJlciB3aGVuIHBhc3NlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge1N0cmluZ30gW2ZsYWdzXVxuICogQHJldHVybiB7Q29tbWFuZH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbW1hbmQucHJvdG90eXBlLnZlcnNpb24gPSBmdW5jdGlvbihzdHIsIGZsYWdzKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgdGhpcy5fdmVyc2lvbiA9IHN0cjtcbiAgZmxhZ3MgPSBmbGFncyB8fCAnLVYsIC0tdmVyc2lvbic7XG4gIHZhciB2ZXJzaW9uT3B0aW9uID0gbmV3IE9wdGlvbihmbGFncywgJ291dHB1dCB0aGUgdmVyc2lvbiBudW1iZXInKTtcbiAgdGhpcy5fdmVyc2lvbk9wdGlvbk5hbWUgPSB2ZXJzaW9uT3B0aW9uLmxvbmcuc3Vic3RyKDIpIHx8ICd2ZXJzaW9uJztcbiAgdGhpcy5vcHRpb25zLnB1c2godmVyc2lvbk9wdGlvbik7XG4gIHRoaXMub24oJ29wdGlvbjonICsgdGhpcy5fdmVyc2lvbk9wdGlvbk5hbWUsIGZ1bmN0aW9uKCkge1xuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKHN0ciArICdcXG4nKTtcbiAgICBwcm9jZXNzLmV4aXQoMCk7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBkZXNjcmlwdGlvbiB0byBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge09iamVjdH0gYXJnc0Rlc2NyaXB0aW9uXG4gKiBAcmV0dXJuIHtTdHJpbmd8Q29tbWFuZH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUuZGVzY3JpcHRpb24gPSBmdW5jdGlvbihzdHIsIGFyZ3NEZXNjcmlwdGlvbikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2Rlc2NyaXB0aW9uO1xuICB0aGlzLl9kZXNjcmlwdGlvbiA9IHN0cjtcbiAgdGhpcy5fYXJnc0Rlc2NyaXB0aW9uID0gYXJnc0Rlc2NyaXB0aW9uO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IGFuIGFsaWFzIGZvciB0aGUgY29tbWFuZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhbGlhc1xuICogQHJldHVybiB7U3RyaW5nfENvbW1hbmR9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkNvbW1hbmQucHJvdG90eXBlLmFsaWFzID0gZnVuY3Rpb24oYWxpYXMpIHtcbiAgdmFyIGNvbW1hbmQgPSB0aGlzO1xuICBpZiAodGhpcy5jb21tYW5kcy5sZW5ndGggIT09IDApIHtcbiAgICBjb21tYW5kID0gdGhpcy5jb21tYW5kc1t0aGlzLmNvbW1hbmRzLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiBjb21tYW5kLl9hbGlhcztcblxuICBpZiAoYWxpYXMgPT09IGNvbW1hbmQuX25hbWUpIHRocm93IG5ldyBFcnJvcignQ29tbWFuZCBhbGlhcyBjYW5cXCd0IGJlIHRoZSBzYW1lIGFzIGl0cyBuYW1lJyk7XG5cbiAgY29tbWFuZC5fYWxpYXMgPSBhbGlhcztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCAvIGdldCB0aGUgY29tbWFuZCB1c2FnZSBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd8Q29tbWFuZH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUudXNhZ2UgPSBmdW5jdGlvbihzdHIpIHtcbiAgdmFyIGFyZ3MgPSB0aGlzLl9hcmdzLm1hcChmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gaHVtYW5SZWFkYWJsZUFyZ05hbWUoYXJnKTtcbiAgfSk7XG5cbiAgdmFyIHVzYWdlID0gJ1tvcHRpb25zXScgK1xuICAgICh0aGlzLmNvbW1hbmRzLmxlbmd0aCA/ICcgW2NvbW1hbmRdJyA6ICcnKSArXG4gICAgKHRoaXMuX2FyZ3MubGVuZ3RoID8gJyAnICsgYXJncy5qb2luKCcgJykgOiAnJyk7XG5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl91c2FnZSB8fCB1c2FnZTtcbiAgdGhpcy5fdXNhZ2UgPSBzdHI7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldCBvciBzZXQgdGhlIG5hbWUgb2YgdGhlIGNvbW1hbmRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd8Q29tbWFuZH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUubmFtZSA9IGZ1bmN0aW9uKHN0cikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX25hbWU7XG4gIHRoaXMuX25hbWUgPSBzdHI7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gcHJlcGFyZWQgY29tbWFuZHMuXG4gKlxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db21tYW5kLnByb3RvdHlwZS5wcmVwYXJlQ29tbWFuZHMgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuY29tbWFuZHMuZmlsdGVyKGZ1bmN0aW9uKGNtZCkge1xuICAgIHJldHVybiAhY21kLl9ub0hlbHA7XG4gIH0pLm1hcChmdW5jdGlvbihjbWQpIHtcbiAgICB2YXIgYXJncyA9IGNtZC5fYXJncy5tYXAoZnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gaHVtYW5SZWFkYWJsZUFyZ05hbWUoYXJnKTtcbiAgICB9KS5qb2luKCcgJyk7XG5cbiAgICByZXR1cm4gW1xuICAgICAgY21kLl9uYW1lICtcbiAgICAgICAgKGNtZC5fYWxpYXMgPyAnfCcgKyBjbWQuX2FsaWFzIDogJycpICtcbiAgICAgICAgKGNtZC5vcHRpb25zLmxlbmd0aCA/ICcgW29wdGlvbnNdJyA6ICcnKSArXG4gICAgICAgIChhcmdzID8gJyAnICsgYXJncyA6ICcnKSxcbiAgICAgIGNtZC5fZGVzY3JpcHRpb25cbiAgICBdO1xuICB9KTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsYXJnZXN0IGNvbW1hbmQgbGVuZ3RoLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbW1hbmQucHJvdG90eXBlLmxhcmdlc3RDb21tYW5kTGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gIHZhciBjb21tYW5kcyA9IHRoaXMucHJlcGFyZUNvbW1hbmRzKCk7XG4gIHJldHVybiBjb21tYW5kcy5yZWR1Y2UoZnVuY3Rpb24obWF4LCBjb21tYW5kKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1heCwgY29tbWFuZFswXS5sZW5ndGgpO1xuICB9LCAwKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsYXJnZXN0IG9wdGlvbiBsZW5ndGguXG4gKlxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUubGFyZ2VzdE9wdGlvbkxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgb3B0aW9ucyA9IFtdLnNsaWNlLmNhbGwodGhpcy5vcHRpb25zKTtcbiAgb3B0aW9ucy5wdXNoKHtcbiAgICBmbGFnczogJy1oLCAtLWhlbHAnXG4gIH0pO1xuICByZXR1cm4gb3B0aW9ucy5yZWR1Y2UoZnVuY3Rpb24obWF4LCBvcHRpb24pIHtcbiAgICByZXR1cm4gTWF0aC5tYXgobWF4LCBvcHRpb24uZmxhZ3MubGVuZ3RoKTtcbiAgfSwgMCk7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGFyZ2VzdCBhcmcgbGVuZ3RoLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbW1hbmQucHJvdG90eXBlLmxhcmdlc3RBcmdMZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2FyZ3MucmVkdWNlKGZ1bmN0aW9uKG1heCwgYXJnKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KG1heCwgYXJnLm5hbWUubGVuZ3RoKTtcbiAgfSwgMCk7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgcGFkIHdpZHRoLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbW1hbmQucHJvdG90eXBlLnBhZFdpZHRoID0gZnVuY3Rpb24oKSB7XG4gIHZhciB3aWR0aCA9IHRoaXMubGFyZ2VzdE9wdGlvbkxlbmd0aCgpO1xuICBpZiAodGhpcy5fYXJnc0Rlc2NyaXB0aW9uICYmIHRoaXMuX2FyZ3MubGVuZ3RoKSB7XG4gICAgaWYgKHRoaXMubGFyZ2VzdEFyZ0xlbmd0aCgpID4gd2lkdGgpIHtcbiAgICAgIHdpZHRoID0gdGhpcy5sYXJnZXN0QXJnTGVuZ3RoKCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMuY29tbWFuZHMgJiYgdGhpcy5jb21tYW5kcy5sZW5ndGgpIHtcbiAgICBpZiAodGhpcy5sYXJnZXN0Q29tbWFuZExlbmd0aCgpID4gd2lkdGgpIHtcbiAgICAgIHdpZHRoID0gdGhpcy5sYXJnZXN0Q29tbWFuZExlbmd0aCgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3aWR0aDtcbn07XG5cbi8qKlxuICogUmV0dXJuIGhlbHAgZm9yIG9wdGlvbnMuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUub3B0aW9uSGVscCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgd2lkdGggPSB0aGlzLnBhZFdpZHRoKCk7XG5cbiAgLy8gQXBwZW5kIHRoZSBoZWxwIGluZm9ybWF0aW9uXG4gIHJldHVybiB0aGlzLm9wdGlvbnMubWFwKGZ1bmN0aW9uKG9wdGlvbikge1xuICAgIHJldHVybiBwYWQob3B0aW9uLmZsYWdzLCB3aWR0aCkgKyAnICAnICsgb3B0aW9uLmRlc2NyaXB0aW9uICtcbiAgICAgICgob3B0aW9uLmJvb2wgJiYgb3B0aW9uLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkKSA/ICcgKGRlZmF1bHQ6ICcgKyBKU09OLnN0cmluZ2lmeShvcHRpb24uZGVmYXVsdFZhbHVlKSArICcpJyA6ICcnKTtcbiAgfSkuY29uY2F0KFtwYWQoJy1oLCAtLWhlbHAnLCB3aWR0aCkgKyAnICAnICsgJ291dHB1dCB1c2FnZSBpbmZvcm1hdGlvbiddKVxuICAgIC5qb2luKCdcXG4nKTtcbn07XG5cbi8qKlxuICogUmV0dXJuIGNvbW1hbmQgaGVscCBkb2N1bWVudGF0aW9uLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkNvbW1hbmQucHJvdG90eXBlLmNvbW1hbmRIZWxwID0gZnVuY3Rpb24oKSB7XG4gIGlmICghdGhpcy5jb21tYW5kcy5sZW5ndGgpIHJldHVybiAnJztcblxuICB2YXIgY29tbWFuZHMgPSB0aGlzLnByZXBhcmVDb21tYW5kcygpO1xuICB2YXIgd2lkdGggPSB0aGlzLnBhZFdpZHRoKCk7XG5cbiAgcmV0dXJuIFtcbiAgICAnQ29tbWFuZHM6JyxcbiAgICBjb21tYW5kcy5tYXAoZnVuY3Rpb24oY21kKSB7XG4gICAgICB2YXIgZGVzYyA9IGNtZFsxXSA/ICcgICcgKyBjbWRbMV0gOiAnJztcbiAgICAgIHJldHVybiAoZGVzYyA/IHBhZChjbWRbMF0sIHdpZHRoKSA6IGNtZFswXSkgKyBkZXNjO1xuICAgIH0pLmpvaW4oJ1xcbicpLnJlcGxhY2UoL14vZ20sICcgICcpLFxuICAgICcnXG4gIF0uam9pbignXFxuJyk7XG59O1xuXG4vKipcbiAqIFJldHVybiBwcm9ncmFtIGhlbHAgZG9jdW1lbnRhdGlvbi5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Db21tYW5kLnByb3RvdHlwZS5oZWxwSW5mb3JtYXRpb24gPSBmdW5jdGlvbigpIHtcbiAgdmFyIGRlc2MgPSBbXTtcbiAgaWYgKHRoaXMuX2Rlc2NyaXB0aW9uKSB7XG4gICAgZGVzYyA9IFtcbiAgICAgIHRoaXMuX2Rlc2NyaXB0aW9uLFxuICAgICAgJydcbiAgICBdO1xuXG4gICAgdmFyIGFyZ3NEZXNjcmlwdGlvbiA9IHRoaXMuX2FyZ3NEZXNjcmlwdGlvbjtcbiAgICBpZiAoYXJnc0Rlc2NyaXB0aW9uICYmIHRoaXMuX2FyZ3MubGVuZ3RoKSB7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLnBhZFdpZHRoKCk7XG4gICAgICBkZXNjLnB1c2goJ0FyZ3VtZW50czonKTtcbiAgICAgIGRlc2MucHVzaCgnJyk7XG4gICAgICB0aGlzLl9hcmdzLmZvckVhY2goZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIGRlc2MucHVzaCgnICAnICsgcGFkKGFyZy5uYW1lLCB3aWR0aCkgKyAnICAnICsgYXJnc0Rlc2NyaXB0aW9uW2FyZy5uYW1lXSk7XG4gICAgICB9KTtcbiAgICAgIGRlc2MucHVzaCgnJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNtZE5hbWUgPSB0aGlzLl9uYW1lO1xuICBpZiAodGhpcy5fYWxpYXMpIHtcbiAgICBjbWROYW1lID0gY21kTmFtZSArICd8JyArIHRoaXMuX2FsaWFzO1xuICB9XG4gIHZhciB1c2FnZSA9IFtcbiAgICAnVXNhZ2U6ICcgKyBjbWROYW1lICsgJyAnICsgdGhpcy51c2FnZSgpLFxuICAgICcnXG4gIF07XG5cbiAgdmFyIGNtZHMgPSBbXTtcbiAgdmFyIGNvbW1hbmRIZWxwID0gdGhpcy5jb21tYW5kSGVscCgpO1xuICBpZiAoY29tbWFuZEhlbHApIGNtZHMgPSBbY29tbWFuZEhlbHBdO1xuXG4gIHZhciBvcHRpb25zID0gW1xuICAgICdPcHRpb25zOicsXG4gICAgJycgKyB0aGlzLm9wdGlvbkhlbHAoKS5yZXBsYWNlKC9eL2dtLCAnICAnKSxcbiAgICAnJ1xuICBdO1xuXG4gIHJldHVybiB1c2FnZVxuICAgIC5jb25jYXQoZGVzYylcbiAgICAuY29uY2F0KG9wdGlvbnMpXG4gICAgLmNvbmNhdChjbWRzKVxuICAgIC5qb2luKCdcXG4nKTtcbn07XG5cbi8qKlxuICogT3V0cHV0IGhlbHAgaW5mb3JtYXRpb24gZm9yIHRoaXMgY29tbWFuZFxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUub3V0cHV0SGVscCA9IGZ1bmN0aW9uKGNiKSB7XG4gIGlmICghY2IpIHtcbiAgICBjYiA9IGZ1bmN0aW9uKHBhc3N0aHJ1KSB7XG4gICAgICByZXR1cm4gcGFzc3RocnU7XG4gICAgfTtcbiAgfVxuICBwcm9jZXNzLnN0ZG91dC53cml0ZShjYih0aGlzLmhlbHBJbmZvcm1hdGlvbigpKSk7XG4gIHRoaXMuZW1pdCgnLS1oZWxwJyk7XG59O1xuXG4vKipcbiAqIE91dHB1dCBoZWxwIGluZm9ybWF0aW9uIGFuZCBleGl0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuQ29tbWFuZC5wcm90b3R5cGUuaGVscCA9IGZ1bmN0aW9uKGNiKSB7XG4gIHRoaXMub3V0cHV0SGVscChjYik7XG4gIHByb2Nlc3MuZXhpdCgpO1xufTtcblxuLyoqXG4gKiBDYW1lbC1jYXNlIHRoZSBnaXZlbiBgZmxhZ2BcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmxhZ1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY2FtZWxjYXNlKGZsYWcpIHtcbiAgcmV0dXJuIGZsYWcuc3BsaXQoJy0nKS5yZWR1Y2UoZnVuY3Rpb24oc3RyLCB3b3JkKSB7XG4gICAgcmV0dXJuIHN0ciArIHdvcmRbMF0udG9VcHBlckNhc2UoKSArIHdvcmQuc2xpY2UoMSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFBhZCBgc3RyYCB0byBgd2lkdGhgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFkKHN0ciwgd2lkdGgpIHtcbiAgdmFyIGxlbiA9IE1hdGgubWF4KDAsIHdpZHRoIC0gc3RyLmxlbmd0aCk7XG4gIHJldHVybiBzdHIgKyBBcnJheShsZW4gKyAxKS5qb2luKCcgJyk7XG59XG5cbi8qKlxuICogT3V0cHV0IGhlbHAgaW5mb3JtYXRpb24gaWYgbmVjZXNzYXJ5XG4gKlxuICogQHBhcmFtIHtDb21tYW5kfSBjb21tYW5kIHRvIG91dHB1dCBoZWxwIGZvclxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgb2Ygb3B0aW9ucyB0byBzZWFyY2ggZm9yIC1oIG9yIC0taGVscFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gb3V0cHV0SGVscElmTmVjZXNzYXJ5KGNtZCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKG9wdGlvbnNbaV0gPT09ICctLWhlbHAnIHx8IG9wdGlvbnNbaV0gPT09ICctaCcpIHtcbiAgICAgIGNtZC5vdXRwdXRIZWxwKCk7XG4gICAgICBwcm9jZXNzLmV4aXQoMCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogVGFrZXMgYW4gYXJndW1lbnQgYW4gcmV0dXJucyBpdHMgaHVtYW4gcmVhZGFibGUgZXF1aXZhbGVudCBmb3IgaGVscCB1c2FnZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXJnXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBodW1hblJlYWRhYmxlQXJnTmFtZShhcmcpIHtcbiAgdmFyIG5hbWVPdXRwdXQgPSBhcmcubmFtZSArIChhcmcudmFyaWFkaWMgPT09IHRydWUgPyAnLi4uJyA6ICcnKTtcblxuICByZXR1cm4gYXJnLnJlcXVpcmVkXG4gICAgPyAnPCcgKyBuYW1lT3V0cHV0ICsgJz4nXG4gICAgOiAnWycgKyBuYW1lT3V0cHV0ICsgJ10nO1xufVxuXG4vLyBmb3IgdmVyc2lvbnMgYmVmb3JlIG5vZGUgdjAuOCB3aGVuIHRoZXJlIHdlcmVuJ3QgYGZzLmV4aXN0c1N5bmNgXG5mdW5jdGlvbiBleGlzdHMoZmlsZSkge1xuICB0cnkge1xuICAgIGlmIChmcy5zdGF0U3luYyhmaWxlKS5pc0ZpbGUoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xubW9kdWxlLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlcigpIHtcbiAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG5cbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgcmVzb2x2ZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXJyb3JMaXN0ZW5lciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGhhbmRsZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCAnZXJyb3InLCBoYW5kbGVyLCBmbGFncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIGxpc3RlbmVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgZW1pdHRlci5vbmNlKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdHRlci5vbihuYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBFdmVudFRhcmdldCBkb2VzIG5vdCBoYXZlIGBlcnJvcmAgZXZlbnQgc2VtYW50aWNzIGxpa2UgTm9kZVxuICAgIC8vIEV2ZW50RW1pdHRlcnMsIHdlIGRvIG5vdCBsaXN0ZW4gZm9yIGBlcnJvcmAgZXZlbnRzIGhlcmUuXG4gICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIHdyYXBMaXN0ZW5lcihhcmcpIHtcbiAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgYnVpbHRpbiBgeyBvbmNlOiB0cnVlIH1gIHN1cHBvcnQgc28gd2VcbiAgICAgIC8vIGhhdmUgdG8gZG8gaXQgbWFudWFsbHkuXG4gICAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgd3JhcExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyKGFyZyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZW1pdHRlclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBFdmVudEVtaXR0ZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBlbWl0dGVyKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9